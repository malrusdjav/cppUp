#include "SmartPointers.h"
#include <iostream>

// RAII idiom: Resourse Acquisition Is Inintialization

/*
	Грамотное завершение работы: открыть файл и потом закрыть,
	открыть подключение по сети и закрыть его,
	работа с mutex (сначала заблокировать какой-то участок кода, 
	а потом его разблокировать),
	выделить память динамически в куче через указатель, а потом ее удалить

	Самостоятельно удалять такие ресурсы не всегда возможно (есть вероятность просто забыть
	или не исполнить этот участок кода).

	Можно дважды освободить память, либо пользоваться указателем после освобождения памяти,
	с сырыми указателями нельзя понять, указывает ли он на один объект или на массив объектов

	Суть идиомы: для таких объектов создается класс-обертка, внутрь которого помещается 
	подобный объект и методы работы с ними: деструктор вызывается в любом случае и 
	и всегда автоматически грамотно завершает работу при выходе из области видимости, где он 
	был изначально создан. Объект никогда не остается в подвешенном состоянии в памяти.

	Умные указатели - реализация идиомы RAII



	Для работы с умными указателями надо подключить библиотеку работы с памятью:
	#include <memory>

	Виды умных указателей:
	
	=======================================================================================
	1. auto_ptr - затычка, первая попытка решить проблему сырых указателей в 99 стандарте


	auto p = auto_ptr<int>(new int(5));

	auto pp = p; //указатель p больше указывает не на область памяти с 5,
				 //а на nullptr, то есть он передал указатель pp

	auto_ptr<int> pp(p)

	=======================================================================================


	2. unique_ptr - немного улучшенная версия auto_ptr из 11 стандарта

	Семантика исключительного владения: одному динамическому объекту
	соответствует один указатель, который нельзя копировать (конструктор копирования удален), 
	а можно только перемещать (move() или swap())

	unique_ptr<int> p1(new int(5));

	unique_ptr<int> p2;
	p2 = move(p1); 

	p2.swap(p1);

	int* raw_ptr = p2.get();

	int* raw_p = new int(5);
	unique_ptr<int> ptr_u(raw_p);

	ptr_u.reset() - забыть адрес, но предварительно затереть по этому адресу данные
	ptr_u.release() - просто забыть адрес, но не очищать данные по этому адресу

	=======================================================================================
	3. shared_ptr - самый ходовой умный указатель, который используется на практике (strong)

	Семантика общего владения: разные указатели могут владеть одним и тем же объектом в 
	динамической памяти

	shared_ptr<int> pt1(new int(5))
	shared_ptr<int> pt2(pt1)
	Данные будут очищены, когда будет удален последний общий указатель на эти данные
	Есть переменная счетчик, которая ответственна за подсчет ссылок, при добавлении нового
	указателя к тем же самым данных счетчик инкрементируется

	Для работы с массивами 

	int SIZE;
	cin >> SIZE; -> 5

	shared_ptr<int[]> arr_ptr(new int[SIZE] {1, 2, 3, 4, 5})

	for(int i = 0; i < SIZE; i++)
		cout << arr_ptr[i] << endl;


	В два раза больше по размеру, потому что хранит в себе не только указатель на данные, но еще
	и счетчик (вообще говоря управляющий блок), сначала оператором new выделяется память под
	данные, а потом вызывается конструктор shared_ptr, в котором инкрементируется счетчик

	make_shared решает эту проблему, также этот вариант лаконичнее и мы можем всегда быть 
	уверены, что конструктор shared_ptr вызовется и к данным будет привязан указатель
	(безопасность исключений)

	Два варианта эквивалентны:
	shared_ptr<int> PTR1(new int);
	auto PTR2 = make_shared<int>();
	=======================================================================================
	4. weak_ptr - ...


	*/
